struct VertexInput
{
	float4 pos : POSITION;
	float4 color : COLOR;
	
	// 여기서 POSITION, COLOR라고 적혀있는 것을 "시멘틱"이라고 부름
	// 간단히 말하면 이 구조체 안에서 정의되어 있는 멤버들에 코드네임을 붙인 것으로,
	
	// 나중에 메인 프로젝트 쪽에서 셰이더에 데이터를 보내왔을 때
	// 보내온 데이터에 매겨져있는 이름과 정확히 일치하는 시멘틱이 있으면
	// 해당 시멘틱을 가진 맴버의 입력된 데이터가 전달됨
	
	// VertexShader의 생성자에서 layouts에 입력된 데이터가
	// 각각 "POSITION", "COLOR"가 있었는데
	// 거기에 적혀있는 데이터들이 여기에 들어오게 되는 것
	
	// 간단히 요약하면 이정표 같은 느낌
};
// 지금 보면 이 구조체들 안의 각 멤버에 시멘틱이 포함되어 있음
// 그리고 이 시멘틱들은 VertexShader.cpp에서 정의되었던 레이아웃과 동일함

// -> VS 클래스 쪽에서 데이터가 들어오면 위의 구조체에 들어오게 된다

struct PixelInput
{
	float4 position : SV_Position;
	// 나중에는 이 픽셀 셰이더에서 출력할 점의 좌표를 알아야 되는 경우가 있음
	// 그럴 때 사용하기 위해 만들어진 시멘틱
	// 지금 당장은 위의 VertexInput과 포맷을 맞추기 위해 추가된 것
	
	float4 color : COLOR;
};

// 위의 두 구조체 : 셰이더에 데이터가 들어왔을 때
// 입력받는 데이터 각각에 이름을 붙여주는 과정

// 이 셰이더라고 하는 것은 DirectX에서 다루는 내용이긴 하지만,
// C++의 문법과 완전히 호환되는 것은 아님
// 따라서 셰이더(HLSL) 고유의 용어에 맞게 구성해줘야 하고,
// 특히 어느 데이터가 추가되는 것인지 셰이터 측에서 알기 어렵기 때문에
// 보내주는 C++ 측에서 데이터의 행선지 및 구조 등을 미리 알려줘야 하는 것
// 그 과정에서 필요한게 위와 같은 입력용 구조체들(포맷)인 것

// 위에서 정의된 두 구조체를 이용하며
// 정점 셰이더에 데이터가 입력됐으면 이를 픽셀 셰이더에서 사용 가능한 형태로 바꿔주는 동시에
// 정점 셰이더에서 처리해야 할 내용이 추가로 있으면 이를 수행하는
// 정점 셰이더의 main에 해당하는 함수
PixelInput VS(VertexInput input)
// 파일을 처음 만들었을 때 기본적으로 만들어지는 이름은 main
// 지금처럼 VS나 PS등으로 이름을 바꾸고자 한다면
// 프로젝트 세팅에서 HLSL의 진입점 이름을 바꾼 함수명으로 바꿔줘야 함
{
	PixelInput output;
	output.position = input.pos;
	output.color = input.color;
	
	return output;
	
	// 실질적으로는 값이 달라졌다 하는 건 없음
	// 하지만 서로 다른 구조체, 특히 각 멤버의 시멘틱이 다른 구조체로 변경
	// 이를 통해 픽셀 셰이더에서 처리가 가능한 식으로 데이터가(정확히는 시멘틱이) 가공된 것
}

// 정점 셰이더에서 가공된 데이터를 이용해서
// 최종적으로 모니터의 한 픽셀에 출력할 색상값을 결정하는
// 픽셀 셰이더의 메인 함수
float4 PS(PixelInput input) : SV_TARGET
{
	return input.color;
	// 입력받은 색상 데이터를 그대로 출력하는 처리만 함
	// 추가적인 설명은 다음 시간에 진행 예정
	
	// 원래대로라면 PixelInput을 통해 입력받은 데이터들을 통해서
	// 어떤 색으로 처리할 것인지를 연산하고 그 결과를 리턴해야 함
	// 그리고 이 PixelInput에는 색상만 지정된 것이 아닌, 입력받은 정점의 위치까지 같이 기록되어 있음
	// 나중에는 이 위치를 가지고 특정 위치에 있는 정점이면 색을 변화시키는 필터 기능도 만들어볼 예정
	// 이런 필터 기능은 한 달 정도 지나서 만들어볼 것이고
	// 지금 당장은 입력받은 색을 출력시키는 데만 집중할 예정
}
